@prefix : <https://quangis.github.io/vocab/tool#> .
@prefix abstr: <https://quangis.github.io/tool/abstract#> .
@prefix arc3d: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/3d-analyst/> .
@prefix arcan: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/analysis/> .
@prefix arcco: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/conversion/> .
@prefix arcdm: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/data-management/> .
@prefix arcgis: <https://quangis.github.io/tool#> .
@prefix arcna: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/network-analyst/> .
@prefix arcsa: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-analyst/> .
@prefix arcss: <https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-statistics/> .
@prefix ccd: <http://geographicknowledge.de/vocab/CoreConceptData.rdf#> .
@prefix cct: <https://quangis.github.io/cct#> .
@prefix multi: <https://quangis.github.io/tool/multi#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

arcgis:AddObjectVectorRegionArea a :Unit ;
    rdfs:seeAlso arcdm:add-geometry-attributes.htm .

arcgis:Aspect a :Unit ;
    rdfs:seeAlso arc3d:aspect.htm .

arcgis:ObjectBuffer a :Unit ;
    rdfs:comment "Buffer (interpreted as vector representation of boolean field)" ;
    rdfs:seeAlso arcan:buffer.htm .

abstr:AddObjectVectorRegionArea a :Abstraction ;
    rdfs:comment "Adds an area attribute to an object vector region layer." ;
    cct:expression """
        1: ObjectInfo(Nom);
        join_attr
            (get_attrL 1)
            (apply1
                (compose size deify)
                (get_attrL 1)
            )
        """ ;
    :input [ a ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:Aspect a :Abstraction ;
    rdfs:comment "Derives the aspect of a digital elevation model" ;
    cct:expression "aspect (1: Field(Itv))" ;
    :input [ a ccd:FieldRaster,
                ccd:IntervalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:Buffer a :Abstraction ;
    cct:expression "extrapol (get_attrL (1: ObjectInfo(Nom)))" ;
    :implementation arcgis:Buffer ;
    :input [ a ccd:LineA,
                ccd:ObjectQ ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:PlainVectorRegionA ] .

abstr:BufferDissolve a :Abstraction ;
    cct:expression "extrapol (get_attrL (1: ObjectInfo(Nom)))" ;
    :implementation multi:BufferDissolve ;
    :input [ a ccd:LineA,
                ccd:NominalA,
                ccd:ObjectQ ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:PlainVectorRegionA ] .

abstr:BuildNetwork a :Abstraction ;
    rdfs:comment "Builds ratio network from line objects." ;
    cct:expression "nbuild (1: ObjectInfo(Ratio))" ;
    :input [ a ccd:LineA,
                ccd:ObjectQ,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:LineA,
                ccd:NetworkQ,
                ccd:RatioA ] .

abstr:CalculateCountAmountRatio a :Abstraction ;
    rdfs:comment "Calculates the ratio of two count vector amounts.",
        "object Content proportion OA/OA" ;
    cct:expression "apply2 ratio (1: Amounts(Ratio)) (2: Amounts(Ratio))" ;
    :implementation multi:CalculateAreaMeasure ;
    :input [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:IRA,
                ccd:VectorRegionA ] .

abstr:CalculateCountAmountRatio2 a :Abstraction ;
    cct:expression "apply2 ratio (1: Amounts(Ratio)) (2: Amounts(Ratio))" ;
    :implementation multi:CalculateCountAmountRatio ;
    :input [ a ccd:AmountQ,
                ccd:CountA,
                ccd:PlainVectorRegionA ;
            :id "1" ],
        [ a ccd:AmountQ,
                ccd:CountA,
                ccd:PlainVectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:AmountQ,
                ccd:IRA,
                ccd:PlainVectorRegionA ] .

abstr:CalculateDensityonObject a :Abstraction ;
    cct:expression """ 1: ObjectInfo(Count);        
        join_attr
            (get_attrL 1)
            (apply2 ratio (get_attrR 1)  (apply1
                (compose size deify)
                (get_attrL 1)
            ))""" ;
    :implementation multi:CalculateDensityonObject ;
    :input [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:CalculateDiversity4onObjectVector a :Abstraction ;
    cct:expression """    1: ObjectInfo(Ratio);
    2: ObjectInfo(Ratio);
    3: ObjectInfo(Ratio);
    4: ObjectInfo(Ratio);
    join_attr
        (get_attrL 1)
        (diversity
            (addlistrel
                (addlistrel
                    (addlistrel            
                        (conslistrel
                            (apply2 ratio 
                                (get_attrR 1)            
                                (apply1 (compose size deify) (get_attrL 1))
                            )
                        )
                        (apply2 ratio 
                                (get_attrR 2)            
                                (apply1 (compose size deify) (get_attrL 2))
                        )
                    )
                    (apply2 ratio 
                                (get_attrR 3)            
                                (apply1 (compose size deify) (get_attrL 3))
                    )
                )
                (apply2 ratio 
                                (get_attrR 4)            
                                (apply1 (compose size deify) (get_attrL 4))
                )    
            )
        )""" ;
    :implementation multi:CalculateDiversity4onObjectVector ;
    :input [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ;
            :id "3" ],
        [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ;
            :id "4" ],
        [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ;
            :id "2" ] ;
    :output [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ] .

abstr:CalculateObjectAttrRatio a :Abstraction ;
    rdfs:comment "<https://pro.arcgis.com/en/pro-app/tool-reference/data-management/calculate-field.htm>",
        "Calculates ratios of two ratio scaled object attributes." ;
    cct:expression """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply2 ratio (get_attrR 1) (get_attrR 2))
        """ ;
    :implementation multi:CalculateAreaMeasure ;
    :input [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:IRA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:CalculateObjectSpatialAmount a :Abstraction ;
    rdfs:comment "Calculates an amount from an object ratio quality (representating an intensive measure) using the object's area. For example, the amount of radiation falling on a building using the mean radiation and the building's area" ;
    cct:expression """
        1: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply2 product
                (get_attrR 1)
                (apply1 (compose size deify) (get_attrL 1))
            )
        """ ;
    :implementation multi:AddandCalculateAttribute ;
    :input [ a ccd:IRA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:CalculateObjectVectorAmountRatio a :Abstraction ;
    cct:expression """        1: ObjectInfo(Count);
        2: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply2 ratio (get_attrR 1) (get_attrR 2))""" ;
    :implementation multi:CalculateObjectVectorAmountRatio ;
    :input [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ] .

abstr:CalculateObjectVectorCountAmountRatio a :Abstraction ;
    rdfs:comment "Calculate new attribute: Object Content proportion OA/OA",
        "Calculates the ratio of two count vector amounts on objects." ;
    cct:expression """
        1: ObjectInfo(Count);
        2: ObjectInfo(Count);
        join_attr
            (get_attrL 1)
            (apply2 ratio (get_attrR 1) (get_attrR 2))
        """ ;
    :implementation multi:CalculateAreaMeasure ;
    :input [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ],
        [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:IRA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:CalculateObjectVectorDensity a :Abstraction ;
    cct:expression """    1: ObjectInfo(Count);        
    join_attr
        (get_attrL 1)
        (apply2 ratio 
            (get_attrR 1)            
            (apply1 (compose size deify) (get_attrL 1))
        )""" ;
    :implementation multi:CalculateObjectVectorDensity ;
    :input [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ] .

abstr:CalculatePartialAmountsfromObjects a :Abstraction ;
    rdfs:comment "Clips some object vector with some count amounts to the extent of a field layer (e.g. a buffer) and interpolates partial count amounts R(Reg, Ratio) based on area percentage." ;
    cct:expression """
        1: ObjectInfo(Count);
        2: Field(Bool);
        arealinterpol
            (getamounts 1)
            (pi2 (groupbyR reify (select eq (loTopo
                (fcover 2 (nest true))
                (get_attrL 1)
            ) in)))
        """ ;
    :implementation multi:CalculatePartialAmounts ;
    :input [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ] .

abstr:CalculatePartialAmountsfromObjects2 a :Abstraction ;
    cct:expression """        1: ObjectInfo(Count);
        2: Field(Bool);
        arealinterpol
            (getamounts 1)
            (pi2 (groupbyR reify (select eq (loTopo
                (fcover 2 (nest true))
                (get_attrL 1)
            ) in)))""" ;
    :implementation multi:CalculatePartialAmountsfromObjects ;
    :input [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:PlainVectorRegionA ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:CountA,
                ccd:PlainVectorRegionA ] .

abstr:CalculateProd a :Abstraction ;
    rdfs:comment "Calculates some product of ratio scaled object attribute with some ratio value." ;
    cct:expression """
        1: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply1 (product (-: Ratio)) (get_attrR 1))
        """ ;
    :implementation multi:AddandCalculateAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorRegionA ] .

abstr:CalculateProdPointObjects a :Abstraction ;
    rdfs:comment "Calculates a product from an attribute using some constant (e.g. time from distance using speed constant)" ;
    cct:expression """
        1: ObjectInfo(Ratio);
        join_attr
            (get_attrL 1)
            (apply1 (product (-: Ratio)) (get_attrR 1))
        """ ;
    :implementation multi:AddandCalculateAttribute ;
    :input [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:CalculateVectorFieldAreaPercentage a :Abstraction ;
    rdfs:comment "Calculates an area ratio (amount) of the size of the extent of the second boolean field with respect to the extent of the first boolean field, both represented by vector layers.",
        "Substance Coverage proportions SC/SC",
        "The assumption is here is that fields are represented by single polygons and area measures are implicitly added. The area measure of the second layer is manually taken over into the calculation. The result is a single measure, though stored into a table with a single polygon." ;
    cct:expression """
        nest2 true (ratio
            (size (fcover (1: Field(Bool)) (nest true)))
            (size (fcover (2: Field(Bool)) (nest true)))
        )
        """ ;
    :implementation multi:CalculateAreaMeasure ;
    :input [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "1" ],
        [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:AmountQ,
                ccd:IRA,
                ccd:VectorRegionA ] .

abstr:CalculateVectorFieldPartialArea a :Abstraction ;
    rdfs:comment "Calculates a partial area measure by multiplying an area proportion with the size of the extent of a vector field.",
        "Substance Coverage SC" ;
    cct:expression "apply1 (product (size (pi1 (1: Field(Nom))))) (2: R2(Bool, Ratio))" ;
    :implementation multi:CalculateAreaMeasure ;
    :input [ a ccd:FieldQ,
                ccd:VectorRegionA ;
            rdfs:comment "field whose extent is interpreted as a Substance Coverage SC" ;
            :id "1" ],
        [ a ccd:AmountQ,
                ccd:IRA,
                ccd:VectorRegionA ;
            rdfs:comment "Substance Coverage proportion SC/SC" ;
            :id "2" ] ;
    :output [ a ccd:AmountQ,
                ccd:ERA,
                ccd:VectorRegionA ] .

abstr:ClipBoolFieldVector2Extent a :Abstraction ;
    rdfs:comment "Clips some boolean field vector to the region where a boolean field vector is true." ;
    cct:expression "subset (1: Field(Bool)) (fcover (2: Field(Bool)) (nest true))" ;
    :implementation arcgis:Clip ;
    :input [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "1" ],
        [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ] .

abstr:ClipFieldRaster2ObjectExtent a :Abstraction ;
    rdfs:comment "Clips some interval scaled field raster to the extent of an object layer." ;
    cct:expression """
        1: Field(Ord);
        2: ObjectInfo(Nom);
        subset 1 (deify (ocover
            (get_attrL 2)
            (pi1 (get_attrL 2))
        ))
        """ ;
    :implementation arcgis:Clip ;
    :input [ a ccd:ObjectVector ;
            :id "2" ],
        [ a ccd:FieldRaster,
                ccd:OrdinalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:OrdinalA ] .

abstr:ClipNomFieldVector2Extent a :Abstraction ;
    rdfs:comment "Clips some nominal field vector to the region where a boolean field vector is true." ;
    cct:expression "subset (1: Field(Nom)) (fcover (2: Field(Bool)) (nest true))" ;
    :implementation arcgis:Clip ;
    :input [ a ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "1" ],
        [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:FieldQ,
                ccd:VectorRegionA ] .

abstr:ClipObject2Object a :Abstraction ;
    rdfs:comment "Clips some object polygons to the extent of an object layer. We assume here that objects exactly coincide (otherwise clip would cut objects)." ;
    cct:expression """
        1: ObjectInfo(Count);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """ ;
    :implementation arcgis:Clip ;
    :input [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            rdfs:comment "objects to be clipped" ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            rdfs:comment "to the regions of these objects" ;
            :id "2" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:ClosestFacilityAnalysis a :Abstraction ;
    rdfs:comment "Selects the distance to the closest goal object on a line network." ;
    cct:expression """
        1: Network(Ratio);
        2: ObjectInfo(Nom);
        3: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyL min (nDist (get_attrL 2) (get_attrL 3) 1))
        """ ;
    :input [ a ccd:ObjectQ,
                ccd:PointA ;
            rdfs:comment "goals" ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:PointA ;
            rdfs:comment "origins" ;
            :id "3" ],
        [ a ccd:LineA,
                ccd:NetworkQ,
                ccd:RatioA ;
            rdfs:comment "roads" ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ] .

abstr:ClostestFacilityAnalysis a :Abstraction ;
    cct:expression """        1: Network(Ratio);
        2: ObjectInfo(Nom);
        3: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyL min (nDist (get_attrL 2) (get_attrL 3) 1))""" ;
    :implementation multi:ClostestFacilityAnalysis ;
    :input [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "3" ],
        [ a ccd:LineA,
                ccd:ObjectQ ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "2" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ] .

abstr:ComputeCountDensityonObject a :Abstraction ;
    cct:expression """ 1: ObjectInfo(Count);        
        join_attr
            (get_attrL 1)
            (apply2 ratio (get_attrR 1)  (apply1
                (compose size deify)
                (get_attrL 1)
            ))""" ;
    :implementation multi:ComputeCountDensityonObject ;
    :input [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:IRA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:ContourToFieldRaster a :Abstraction ;
    rdfs:comment "Converts contour maps to field Rasters" ;
    cct:expression "revert (1: Contour)" ;
    :implementation arcgis:PolygonToRaster ;
    :input [ a ccd:Contour ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:PlainOrdinalA ] .

abstr:ConvertDist2TravelTimeonObjects a :Abstraction ;
    cct:expression """    1: ObjectInfo(Ratio);
    join_attr
        (get_attrL 1)
        (apply1 (product (-:Ratio)) (get_attrR 1))""" ;
    :implementation multi:ConvertDist2TravelTimeonObjects ;
    :input [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ] .

abstr:CoverageToNominalFieldRaster a :Abstraction ;
    rdfs:comment "Converts Field polygons to nominal field Rasters" ;
    cct:expression "revert (1: Coverages(Nom))" ;
    :implementation arcgis:PolygonToRaster ;
    :input [ a ccd:Coverage,
                ccd:PlainNominalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:PlainNominalA ] .

abstr:CreateAndBuildNetwork a :Abstraction ;
    cct:expression "nbuild (1: ObjectInfo(Ratio))" ;
    :implementation multi:CreateAndBuildNetwork ;
    :input [ a ccd:LineA,
                ccd:ObjectQ,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:LineA,
                ccd:NetworkQ,
                ccd:RatioA ] .

abstr:CreateNetwork a :Abstraction ;
    cct:expression """    1: ObjectInfo(Nom);
    nbuild(
        join_attr
            (get_attrL 1)
            (apply1
                (compose size deify)
                (get_attrL 1)
            )
    )""" ;
    :implementation multi:CreateNetwork ;
    :input [ a ccd:LineA,
                ccd:NominalA,
                ccd:ObjectQ ;
            :id "1" ] ;
    :output [ a ccd:LineA,
                ccd:NetworkQ,
                ccd:RatioA ] .

abstr:CreateRandomPoints a :Abstraction ;
    cct:expression "generateobjects (1: ObjectInfo(Nom))" ;
    :implementation arcgis:CreateRandomPoints ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:CreateUnitHydrograph a :Abstraction ;
    rdfs:comment "Creates a unit hydrograph from an isochrones raster based on isochrone interval. This is a table that indicates for each time interval an areal coverage" ;
    cct:expression """
        apply1 ((swap ratio) (-: Ratio)) (groupby size (1: Field(Ord)))
        """ ;
    :implementation multi:RasterCoverage ;
    :input [ a ccd:FieldRaster,
                ccd:OrdinalA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:LayerA,
                ccd:RatioA ] .

abstr:DerivePartsOfPopCenters a :Abstraction ;
    cct:expression """        1: ObjectInfo(Ratio);
        2: Field(Bool);
        arealinterpol
            (getamounts 1)
            (pi2 (groupbyR reify (select eq (loTopo
                (fcover 2 (nest true))
                (get_attrL 1)
            ) in)))""" ;
    :implementation multi:DerivePartsOfPopCenters ;
    :input [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:PlainVectorRegionA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:EraseFieldExtentfromFieldVector a :Abstraction ;
    rdfs:comment "Erases the coverage of a boolean field vector (second input) from a field vector (first input)" ;
    cct:expression """
        1: Field(Nom);
        2: Field(Bool);
        subset
            1
            (pi1 (select
                eq
                (lTopo (pi1 1) (reify (fcover 2 (nest true))))
                out
            ))
        """ ;
    :implementation arcgis:Erase ;
    :input [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:FieldQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:FieldQ,
                ccd:PlainVectorRegionA ] .

abstr:ExportFeatures a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation arcgis:ExportFeatures ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:ExtractByMask a :Abstraction ;
    rdfs:comment "Extract raster by the extent of another (field) raster." ;
    cct:expression "subset (1: Field(Loc)) (pi1 (2: Field(Nom)))" ;
    :implementation arcgis:ExtractByMask ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "Flow directions by watershed mask" ;
            :id "1" ],
        [ a ccd:FieldRaster ;
            :id "2" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:FC2FCObjectTess a :Abstraction ;
    rdfs:comment "Object selection variant by id." ;
    cct:expression """
        subset (1: ObjectInfo(Nom)) (-: C(Obj))
        """ ;
    :implementation arcgis:FC2FC ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:FeatureClassToFeatureClass a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation arcgis:FeatureClassToFeatureClass ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:FeatureClassToFeatureClass2 a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation arcgis:FeatureClassToFeatureClass ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:FlowAccumulation a :Abstraction ;
    rdfs:comment "Accumulates flow directions into areas reachable downstream." ;
    cct:expression "apply1 size (accumulate (1: Field(Loc)))" ;
    :implementation arcgis:FlowAccumulation ;
    :input [ a ccd:CyclicA,
                ccd:FieldRaster ;
            rdfs:comment "Needs to be a direction" ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:FlowDirection a :Abstraction ;
    rdfs:comment "Computes a grid graph of flow directions from a DEM." ;
    cct:expression "flowdirgraph (1: Field(Itv))" ;
    :implementation arcgis:FlowDirection ;
    :input [ a ccd:FieldRaster,
                ccd:IntervalA ;
            rdfs:comment "DEM" ;
            :id "1" ] ;
    :output [ a ccd:CyclicA,
                ccd:FieldRaster ] .

abstr:FlowLength a :Abstraction ;
    rdfs:comment "Calculate the upstream or downstream distance, or weighted distance (=time), along the flow path for each cell." ;
    cct:expression """
        1: Field(Ratio);
        2: Field(Loc);
        groupbyL max (relunion (pi2 (apply2
            (lgDist (gridgraph 2 1))
            (apply nest (pi1 2)) (accumulate 2)
        )))
        """ ;
    :implementation arcgis:FlowLength ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "Flow direction raster;" ;
            :id "2" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "Impedance Weight raster (e.g. 1/velocity raster)" ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "Flow time raster" ] .

abstr:GenerateIntersections a :Abstraction ;
    cct:expression """    1: ObjectInfo(Nom);        
    join_attr     
    (nIntersections((get_attrL 1), (get_attrL 1)))
    (apply nominalize 
        (pi1 
            (nIntersections((get_attrL 1), (get_attrL 1)))   
        )
    )""" ;
    :implementation multi:GenerateIntersections ;
    :input [ a ccd:LineA,
                ccd:NominalA,
                ccd:ObjectQ ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:GenerateNearTable a :Abstraction ;
    cct:expression """1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 1)
            (groupbyL min (oDist (get_attrL 1) (get_attrL 2)))""" ;
    :implementation arcgis:GenerateNearTable ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "2" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ] .

abstr:IDWInterval a :Abstraction ;
    rdfs:comment "Standard point interpolation for interval measurements." ;
    cct:expression "interpol (1: PointMeasures) (deify (-: Reg))" ;
    :implementation arcgis:IDWInterval ;
    :input [ a ccd:IntervalA,
                ccd:PointMeasures ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:IntervalA ] .

abstr:InterpolateDensityonObjects2LineObject a :Abstraction ;
    cct:expression """1: ObjectInfo(Ratio);
2: ObjectInfo(Nom);
arealinterpol
(getamounts 1)
(pi2 (get_attrL 2))""" ;
    :implementation multi:InterpolateDensityonObjects2LineObject ;
    :input [ a ccd:LineA,
                ccd:NominalA,
                ccd:ObjectQ ;
            :id "2" ],
        [ a ccd:IRA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:IRA,
                ccd:LineA,
                ccd:ObjectQ ] .

abstr:IntersectDissolveField2Object a :Abstraction ;
    rdfs:comment "Coverage of vector field in object",
        "Intersects a field vector with an object vector and then dissolves the result into the object to measure the areal coverage of the field inside the object." ;
    cct:expression """
        1: Field(Nom);
        2: ObjectInfo(_);
        join_attr
            (get_attrL 2)
            (groupbyR size (select eq (loTopo
                (fcover 1 (-: C(Nom)))
                (get_attrL 2)
            ) in))
        """ ;
    :implementation multi:IntersectDissolve ;
    :input [ a ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:JoinCountAttribute a :Abstraction ;
    cct:expression """1: R2(Obj, Count);
2: ObjectExtent; 
join_attr 2 1""" ;
    :implementation multi:JoinCountAttribute ;
    :input [ a ccd:CountA,
                ccd:ObjectQ ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:JoinObjectRatios a :Abstraction ;
    cct:expression """1:ObjectInfo(Nom);
    2:ObjectInfo(Ratio);
    join_attr (get_attrL 1) (get_attrR 2)""" ;
    :implementation multi:JoinObjectRatios ;
    :input [ a ccd:ObjectQ,
                ccd:RatioA ;
            :id "2" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:KernelDensity a :Abstraction ;
    cct:expression """    1: ObjectInfo(Ratio);
    groupbyL 
        (compose sum (apply2 product (get_attrR 1))) 
        (loDist (-:R1(Loc)) (get_attrL 1))""" ;
    :implementation arcgis:KernelDensity ;
    :input [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:FieldQ,
                ccd:RasterA,
                ccd:RatioA ] .

abstr:KrigingInterval a :Abstraction ;
    rdfs:comment "Kriging point interpolation for interval measurements." ;
    cct:expression "interpol (1: PointMeasures) (deify (-: Reg))" ;
    :implementation arcgis:KrigingInterval ;
    :input [ a ccd:IntervalA,
                ccd:PointMeasures ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:IntervalA ] .

abstr:LoadAmountonObjects a :Abstraction ;
    rdfs:comment "Loads object based count amounts from excel and joins them with vector objects." ;
    cct:expression """
        1: R2(Obj, Count);
        2: ObjectInfo(_);
        join_attr (get_attrL 2) 1
        """ ;
    :implementation multi:JoinFromTable ;
    :input [ a ccd:CountA,
                ccd:ObjectQ ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:LoadCountAmounts a :Abstraction ;
    cct:expression """        1: R2(Obj, Count);
        2: ObjectInfo(_);
        join_attr (get_attrL 2) 1""" ;
    :implementation multi:LoadCountAmounts ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:LocalMapAlgebraDivide a :Abstraction ;
    rdfs:comment "Builds and executes a Local Map Algebra expression that divides rasters by a ratio number" ;
    cct:expression "apply1 ((swap ratio) (-: Ratio)) (1: Field(Ratio))" ;
    :implementation arcgis:RasterCalculator ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:LocalMapAlgebraInvert a :Abstraction ;
    rdfs:comment "Builds and executes a Local Map Algebra expression that inverts rasters with a ratio level." ;
    cct:expression "apply1 (ratio (-: Ratio)) (1: Field(Ratio))" ;
    :implementation arcgis:RasterCalculator ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:LocalMapAlgebraSubOrder a :Abstraction ;
    rdfs:comment "Builds and executes a Local Map Algebra expression (smaller than or greater than some number) using Python syntax using rasters with an ordinal level",
        "local map algebra with only a single input layer" ;
    cct:expression "select (compose2 notj leq) (1: Field(Ord)) (-: Ord)" ;
    :implementation arcgis:RasterCalculator ;
    :input [ a ccd:FieldRaster,
                ccd:OrdinalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:OrdinalA ] .

abstr:LocalMapAlgebraSubRatio a :Abstraction ;
    rdfs:comment "Builds and executes a Local Map Algebra expression (less than or equal to some number) using Python syntax using rasters with a ratio level",
        "local map algebra transformation with ratio field" ;
    cct:expression "select (compose2 notj leq) (1: Field(Ratio)) (-: Ratio)" ;
    :implementation arcgis:RasterCalculator ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:MakePointMeasuresFromTable a :Abstraction ;
    rdfs:comment "Makes a layer of pointmeasures from some XY table." ;
    cct:expression "1: PointMeasures" ;
    :implementation multi:MakeLayerFromTable ;
    :input [ a ccd:IntervalA,
                ccd:PointMeasures ;
            :id "1" ] ;
    :output [ a ccd:IntervalA,
                ccd:PointMeasures ] .

abstr:Merge a :Abstraction ;
    cct:expression """ set_union(
        3:ObjectInfo(Nom),
        set_union(
            1:ObjectInfo(Nom), 
            2:ObjectInfo(Nom)
            )
        )""" ;
    :implementation arcgis:Merge ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "2" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "3" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:MergeObjects a :Abstraction ;
    rdfs:comment "Merges object parts into single objects based on object identifiers stored as names." ;
    cct:expression """
        1: ObjectInfo(Nom);
        join_attr
            (groupby
                (compose merge (compose pi2 (subset (get_attrL 1))))
                (apply1 objectify (get_attrR 1))
            )
            (getobjectnames (pi2 (get_attrR 1)))
        """ ;
    :implementation arcgis:Dissolve ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:NearPointObjects a :Abstraction ;
    rdfs:comment "Near tool, to seach for the closest objects using Euclidean distance." ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 1)
            (groupbyL min (oDist (get_attrL 1) (get_attrL 2)))
        """ ;
    :implementation arcgis:NearPointObjects ;
    :input [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "2" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ] .

abstr:ObjectBuffer a :Abstraction ;
    rdfs:comment "Buffers some object vector and returns the buffer as a boolean field R(Loc, Bool)" ;
    cct:expression "extrapol (get_attrL (1: ObjectInfo(Nom)))" ;
    :input [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:FieldQ,
                ccd:PlainVectorRegionA ] .

abstr:ObjectSummaryStatisticsAmount a :Abstraction ;
    rdfs:comment "Sums the amount values of an object layer into a sum" ;
    cct:expression "contentsum (getamounts (1: ObjectInfo(Ratio)))" ;
    :implementation arcgis:SummaryStatistics ;
    :input [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ] .

abstr:RasterToContourInterval a :Abstraction ;
    rdfs:comment "Converts a field raster to a Contour dataset. The raster is first reclassified to an ordinal raster, and then converted to a polygon layer." ;
    cct:expression "invert (apply1 classify (1: Field(Itv)))" ;
    :implementation multi:RasterToContour ;
    :input [ a ccd:FieldRaster,
                ccd:IntervalA ;
            :id "1" ] ;
    :output [ a ccd:Contour,
                ccd:PlainOrdinalA ] .

abstr:RasterToIsoRaster a :Abstraction ;
    rdfs:comment "Converts an interval field raster into an ordinal raster." ;
    cct:expression "apply1 classify (1: Field(Itv))" ;
    :implementation arcgis:RasterToIsoRaster ;
    :input [ a ccd:FieldRaster,
                ccd:IntervalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:PlainOrdinalA ] .

abstr:RegionFromRasterExtent a :Abstraction ;
    rdfs:comment "Make a region layer from the extent of a raster. Measures the coverage of a nominal field." ;
    cct:expression """
        1: Field(Nom);
        nest2 (name (pi2 1)) (reify (fcover 1 (pi2 1)))
        """ ;
    :implementation arcgis:RegionFromRasterExtent ;
    :input [ a ccd:FieldRaster,
                ccd:NominalA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:NominalA,
                ccd:VectorRegionA ] .

abstr:RouteAnalysis a :Abstraction ;
    cct:expression """1: Network(Ratio);
2: ObjectInfo(Nom);
3: ObjectInfo(Nom);        
           generateobjectsfromrel (nRoutes (get_attrL 2) (get_attrL 3) 1)""" ;
    :implementation multi:RouteAnalysis ;
    :input [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "3" ],
        [ a ccd:LineA,
                ccd:NetworkQ,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:LineA,
                ccd:NominalA,
                ccd:ObjectQ ] .

abstr:SelectFeaturesByObjectPlainRegionObjects a :Abstraction ;
    rdfs:comment "Select region objects by id" ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Obj))" ;
    :implementation multi:FullSelectFeatures ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectFeaturesCoverageToExistenceVector a :Abstraction ;
    rdfs:comment "Select patches of a coverage by attribute" ;
    cct:expression "revert (select eq (invert (1: Field(Itv)): Coverages(Nom)) (-: Nom))" ;
    :implementation multi:FullSelectFeatures ;
    :input [ a ccd:Coverage ;
            :id "1" ] ;
    :output [ a ccd:FieldQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByAttribute a :Abstraction ;
    cct:expression "revert (select eq (invert (1: Field(Nom)): Coverages(Nom)) (-: Nom))" ;
    :implementation arcgis:SelectLayerByAttribute ;
    :input [ a ccd:FieldQ,
                ccd:NominalA,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:FieldQ,
                ccd:NominalA,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByAttribute2 a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation arcgis:SelectLayerByAttribute ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:SelectLayerByAttribute3 a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation arcgis:SelectLayerByAttribute ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByAttributeLineObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:LineA,
                ccd:NominalA,
                ccd:ObjectQ ;
            :id "1" ] ;
    :output [ a ccd:LineA,
                ccd:NominalA,
                ccd:ObjectQ ] .

abstr:SelectLayerByAttributePlainRegionObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByAttributePointObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:SelectLayerByAttributeTessObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByAttributeTessObjects2 a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation multi:SelectLayerByAttributeTessObjects ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByLocation a :Abstraction ;
    cct:expression """        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))""" ;
    :implementation arcgis:SelectLayerByLocation ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "2" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:SelectLayerByLocationDistTessObject a :Abstraction ;
    cct:expression """        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                leq
                (oDist (get_attrL 1) (get_attrL 2))
                (-: Ratio)
            ))""" ;
    :implementation multi:SelectLayerByLocationDistTessObject ;
    :input [ a ccd:LineA,
                ccd:NominalA,
                ccd:ObjectQ ;
            :id "2" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByLocationLineObjects a :Abstraction ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "2" ],
        [ a ccd:LineA,
                ccd:ObjectQ ;
            :id "1" ] ;
    :output [ a ccd:LineA,
                ccd:ObjectQ ] .

abstr:SelectLayerByLocationPlainRegionObjects a :Abstraction ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByLocationPlainRegionObjectsDist a :Abstraction ;
    rdfs:comment "Object selection variant with distance" ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                leq
                (oDist (get_attrL 1) (get_attrL 2))
                (-: Ratio)
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByLocationPlainRegionObjectsFieldDist a :Abstraction ;
    rdfs:comment "Object selection variant with vector field patches" ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: Field(Nom);
        subset
            1
            (pi3 (select
                eq
                (loTopo (pi1 2) (get_attrL 1))
                in
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ],
        [ a ccd:FieldQ,
                ccd:VectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByLocationPointObjects a :Abstraction ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "2" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA ] .

abstr:SelectLayerByLocationPointObjects1 a :Abstraction ;
    cct:expression """        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))""" ;
    :implementation multi:SelectLayerByLocationPointObjects1 ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA ] .

abstr:SelectLayerByLocationPointObjects2 a :Abstraction ;
    cct:expression """        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))""" ;
    :implementation multi:SelectLayerByLocationPointObjects2 ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA ] .

abstr:SelectLayerByLocationTessObject a :Abstraction ;
    cct:expression """        1: ObjectInfo(Count);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))""" ;
    :implementation multi:SelectLayerByLocationTessObject ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByLocationTessObjects a :Abstraction ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))
        """ ;
    :implementation multi:FullSelectLayerByLocation ;
    :input [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SelectLayerByObjectLineObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Obj))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:LineA,
                ccd:ObjectQ ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:LineA,
                ccd:ObjectQ ] .

abstr:SelectLayerByObjectPlainRegionObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Obj))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByObjectPointObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Obj))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:SelectLayerByObjectTessObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Obj))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:BooleanA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerByRatioGEQPlainRegionObjects a :Abstraction ;
    rdfs:comment "Object selection variant vith gteq, needs a ratio attribute" ;
    cct:expression "select (compose2 notj leq) (1: ObjectInfo(Ratio)) (-: Ratio)" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:SelectLayerByRatioLineObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:LineA,
                ccd:ObjectQ,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:LineA,
                ccd:ObjectQ,
                ccd:RatioA ] .

abstr:SelectLayerByRatioPlainRegionObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:SelectLayerByRatioPointObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ] .

abstr:SelectLayerByRatioTessObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Ratio)) (-: C(Ratio))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:SelectLayerContourToExistenceVector a :Abstraction ;
    rdfs:comment "Contour to Existence Vector (select a contour map greater than some ordinal value)" ;
    cct:expression "revert (select (compose2 notj leq) (1: Contour) (-: Ord))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:FieldQ,
                ccd:OrdinalA,
                ccd:VectorTessellationA ;
            rdfs:comment "Contour is a coverage that is a subclass of coverage and ordinalA, and therefore also allows field rasters, which we don't want in this context." ;
            :id "1" ] ;
    :output [ a ccd:FieldQ,
                ccd:OrdinalA,
                ccd:PlainVectorRegionA ] .

abstr:SelectLayerCoverageToExistenceVector a :Abstraction ;
    cct:expression "revert (select eq (1: Coverages(Nom)) (-: Nom))" ;
    :implementation multi:FullSelectLayerByAttribute ;
    :input [ a ccd:FieldQ,
                ccd:VectorTessellationA ;
            rdfs:comment "Coverage is defined as a subclass of FieldQ and TesselationA, and therefore also allows field rasters, which we don't want in this context." ;
            :id "1" ] ;
    :output [ a ccd:FieldQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectNeighborhoodsByAttributeTessObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation multi:SelectNeighborhoodsByAttributeTessObjects ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectNeighborhoodsByLocationDistPointObject a :Abstraction ;
    cct:expression """        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                leq
                (oDist (get_attrL 1) (get_attrL 2))
                (-:Ratio)
            ))""" ;
    :implementation multi:SelectNeighborhoodsByLocationDistPointObject ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "2" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:SelectNeighborhoodsByRatioObjects a :Abstraction ;
    cct:expression "select (compose2 notj leq) (1: ObjectInfo(Ratio)) (-: Ratio)" ;
    :implementation multi:SelectNeighborhoodsByRatioObjects ;
    :input [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:SelectObjectbyExtent a :Abstraction ;
    rdfs:comment "Select object vector by extent. Extent remains implicit." ;
    cct:expression """
        1: ObjectInfo(Nom);
        subset 1 (pi3 (select
            eq
            (loTopo (deify (-: Reg)) (get_attrL 1))
            in
        ))
        """ ;
    :implementation arcgis:SelectObjectByExtent ;
    :input [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:VectorA ] .

abstr:SelectSchoolsByLocationPointObject a :Abstraction ;
    cct:expression """        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        subset
            1
            (pi1 (select
                eq
                (oTopo (get_attrL 1) (get_attrL 2))
                in
            ))""" ;
    :implementation multi:SelectSchoolsByLocationPointObject ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:SelectWOZByRatioObjects a :Abstraction ;
    cct:expression "select (compose2 notj leq) (1: ObjectInfo(Ratio)) (-: Ratio)" ;
    :implementation multi:SelectWOZByRatioObjects ;
    :input [ a ccd:ObjectQ,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:RatioA ] .

abstr:Slope a :Abstraction ;
    rdfs:comment "Computes slopes of a DEM." ;
    cct:expression "slope (1: Field(Itv))" ;
    :implementation arcgis:Slope ;
    :input [ a ccd:FieldRaster,
                ccd:IntervalA ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:SnapPourPoint a :Abstraction ;
    rdfs:comment "Snaps a pour point to a raster to generate a raster showing the pour point." ;
    cct:expression """
        # This is a simplification that ignores flow accumulation, but just
        # generates a nominal patch from an object nominal
        1: ObjectInfo(Nom);
        join (revert (get_attrL 1)) (get_attrR 1)
        """ ;
    :implementation arcgis:SnapPourPoint ;
    :input [ a ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "flow accumulation raster" ;
            :id "2" ] ;
    :output [ a ccd:FieldQ,
                ccd:PlainNominalA,
                ccd:RasterA ] .

abstr:SpatialJoin a :Abstraction ;
    cct:expression """        1: ObjectInfo(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join (get_attrL 2) (groupbyR sum (join_key
                (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in)
                (getamounts 1)
            )))""" ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ;
            :id "1" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:SpatialJoinAmountSumTessCount a :Abstraction ;
    rdfs:comment "Sums the attributes at Count measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Count data." ;
    cct:expression """
        1: Amounts(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR sum (join_key
                    (select
                        eq
                        (rTopo (pi1 1) (pi2 (get_attrL 2)))
                        in
                    )
                    1
                ))
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinAmountSumTessRatio a :Abstraction ;
    rdfs:comment "Spatial join with sum rule with vector amounts",
        "Sums the attributes at ratio measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Ratio data" ;
    cct:expression """
        1: Amounts(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2) (join
                (get_attrL 2)
                (groupbyR sum (join_key
                    (select
                        eq
                        (rTopo (pi1 1) (pi2 (get_attrL 2)))
                        in)
                    1
                ))
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:AmountQ,
                ccd:ERA,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinCountTess a :Abstraction ;
    rdfs:comment "Counts the number of features from one feature to another based on the spatial relation",
        "spatial join with the count rule",
        "with JOIN_ONE_TO_ONE parameter and with Merge_RULe count" ;
    cct:expression """
        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (apply1
                (ocont (get_attrL 1))
                (get_attrL 2)
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinMeanTessCount a :Abstraction ;
    rdfs:comment "Averages the attributes at Count measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for Count data" ;
    cct:expression """
        1: ObjectInfo(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR avg (join_key (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in) (getamounts 1)))
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinMeanTessInterval a :Abstraction ;
    rdfs:comment "Averages the attributes at interval measurement level from one feature to another based on the spatial relation",
        "spatial join with mean rule",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for interval data" ;
    cct:expression """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR avg (join_key (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in) (getamounts 1)))
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:IntervalA,
                ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:IntervalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinMeanTessRatio a :Abstraction ;
    rdfs:comment "Averages the attributes at Ratio measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe mean for Ratio data" ;
    cct:expression """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join
                (get_attrL 2)
                (groupbyR avg (join_key (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in) (getamounts 1)))
            )
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ] ;
    :output [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinSumTessCount a :Abstraction ;
    rdfs:comment "Sums the attributes at Count measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Count data" ;
    cct:expression """
        1: ObjectInfo(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join (get_attrL 2) (groupbyR sum (join_key
                (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in)
                (getamounts 1)
            )))
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SpatialJoinSumTessRatio a :Abstraction ;
    rdfs:comment "Spatial join with sum rule",
        "Sums the attributes at ratio measurement level from one feature to another based on the spatial relation",
        "with JOIN_ONE_TO_ONE parameter, with Merge_RULe sum for Ratio data" ;
    cct:expression """
        1: ObjectInfo(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (join (get_attrL 2) (groupbyR sum (join_key
                (select eq (rTopo
                    (pi2 (get_attrL 1))
                    (pi2 (get_attrL 2))
                ) in)
                (getamounts 1)
            )))
        """ ;
    :implementation arcgis:SpatialJoin ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SummarizeWithin a :Abstraction ;
    cct:expression """        1: ObjectInfo(Nom);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (apply1
                (ocont (get_attrL 1))
                (get_attrL 2)
            )""" ;
    :implementation arcgis:SummarizeWithin ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:SummarizeWithin2 a :Abstraction ;
    cct:expression """    1: Field(Nom);
    2: ObjectInfo(Nom);
    join_attr
            (get_attrL 2)
            (apply1 
                (compose size pi1) 
                (apply1 
                    (compose (subset (1)) deify) 
                    (get_attrL 2)
                )
            )""" ;
    :implementation arcgis:SummarizeWithin ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:FieldQ,
                ccd:NominalA,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:RatioA,
                ccd:VectorTessellationA ] .

abstr:SummaryStatistics a :Abstraction ;
    cct:expression "contentsum (getamounts (1: ObjectInfo(Ratio)))" ;
    :implementation arcgis:SummaryStatistics ;
    :input [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:CountA,
                ccd:PlainVectorRegionA ] .

abstr:SummaryStatistics2 a :Abstraction ;
    cct:expression "contentsum (1: Amounts(Ratio))" ;
    :implementation arcgis:SummaryStatistics ;
    :input [ a ccd:AmountQ,
                ccd:CountA,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:CountA,
                ccd:PlainVectorRegionA ] .

abstr:SummaryStatistics3 a :Abstraction ;
    cct:expression """    1: ObjectInfo(Ratio);     
    join_attr  
    (nest2 (objectfromobjects (pi1 1)) (avg (getamounts 1))) 
    (nest2 (objectfromobjects (pi1 1))  (merge (pi1 (getamounts 1))))""" ;
    :implementation arcgis:SummaryStatistics ;
    :input [ a ccd:ObjectQ,
                ccd:PointA,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA,
                ccd:RatioA ] .

abstr:SummaryStatisticsAmount a :Abstraction ;
    rdfs:comment "Sums the amount values of a count amount layer into a sum" ;
    cct:expression "contentsum (1: Amounts(Ratio))" ;
    :implementation arcgis:SummaryStatistics ;
    :input [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:AmountQ,
                ccd:CountA,
                ccd:VectorRegionA ] .

abstr:TSPRouting a :Abstraction ;
    cct:expression """1: Network(Ratio);
2: ObjectInfo(Nom);
3: ObjectInfo(Nom);        
           nRoutes (get_attrL 2) (get_attrL 3) 1""" ;
    :implementation multi:TSPRouting ;
    :input [ a ccd:LineA,
                ccd:NetworkQ,
                ccd:RatioA ;
            :id "1" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "2" ],
        [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "3" ] ;
    :output [ a ccd:LineA,
                ccd:NetworkQ ] .

abstr:VelocityFieldDEM a :Abstraction ;
    rdfs:comment "Computes velocity field from DEM." ;
    cct:expression "apply2 product (1: Field(Ratio)) (2: Field(Ratio))" ;
    :implementation multi:VelocityField ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "slope" ;
            :id "1" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "accumulation area" ;
            :id "2" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "velocity" ] .

abstr:Watershed a :Abstraction ;
    rdfs:comment "Given a flow direction raster and a pour point raster, generates a watershed raster." ;
    cct:expression """
        revert (join
            (invert (2: Field(Nom)))
            (invert (apply1 reify (accumulate (1: Field(Loc)))))
        )
        """ ;
    :implementation arcgis:Watershed ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "flow direction raster" ;
            :id "1" ],
        [ a ccd:FieldQ,
                ccd:PlainNominalA,
                ccd:RasterA ;
            rdfs:comment "pour point raster" ;
            :id "2" ] ;
    :output [ a ccd:FieldQ,
                ccd:PlainNominalA,
                ccd:RasterA ;
            rdfs:comment "watershed raster, gives a different watershed id for each pour point" ] .

abstr:ZonalStatisticsMeanInterval a :Abstraction ;
    rdfs:comment "Calculates the average value of a field raster within the zones of a lattice." ;
    cct:expression """
        1: Field(Itv);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (apply1 (fcont avg 1) (get_attrL 2))
        """ ;
    :implementation multi:ZonalStatistics ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "2" ],
        [ a ccd:FieldRaster,
                ccd:IntervalA ;
            :id "1" ] ;
    :output [ a ccd:IntervalA,
                ccd:ObjectQ,
                ccd:VectorTessellationA ] .

abstr:ZonalStatisticsMeanRatio a :Abstraction ;
    rdfs:comment "Calculates the average value of a field raster within the zones given by object regions. Outcome is intensive." ;
    cct:expression """
        1: Field(Ratio);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyR avg (join_key
                (select eq (loTopo (pi1 1) (get_attrL 2)) in)
                1
            ))
        """ ;
    :implementation multi:ZonalStatistics ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            :id "1" ],
        [ a ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "2" ] ;
    :output [ a ccd:IRA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:ZonalStatisticsSize a :Abstraction ;
    rdfs:comment "Measures the size of the coverage of a given field raster inside object regions." ;
    cct:expression """
        1: Field(Nom);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyR size (select eq (loTopo
                (fcover 1 (-: C(Nom)))
                (get_attrL 2)
            ) in))
        """ ;
    :implementation multi:ZonalStatistics ;
    :input [ a ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:FieldRaster,
                ccd:NominalA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:ZonalStatisticsSumCount a :Abstraction ;
    rdfs:comment "Sums up count amounts (given as raster) into object regions." ;
    cct:expression """
        1: Amounts(Count);
        2: ObjectInfo(Nom);
        join_attr
            (get_attrL 2)
            (groupbyL
                sum
                (join_key (orTopo (get_attrL 2) (pi1 1)) 1)
            )
        """ ;
    :implementation multi:ZonalStatistics ;
    :input [ a ccd:ObjectQ,
                ccd:VectorRegionA ;
            :id "2" ],
        [ a ccd:AmountQ,
                ccd:CountA,
                ccd:RasterA ;
            :id "1" ] ;
    :output [ a ccd:CountA,
                ccd:ObjectQ,
                ccd:VectorRegionA ] .

abstr:ZonalStatisticsSumField a :Abstraction ;
    cct:expression """    1: Field(Ratio);
    2: ObjectInfo(Nom);
    join_attr
        (get_attrL 2)
        (groupbyR sum (join_key
            (select eq (loTopo (pi1 1) (get_attrL 2)) in)
            1
        )) """ ;
    :implementation multi:ZonalStatisticsSumField ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "2" ],
        [ a ccd:FieldQ,
                ccd:RasterA,
                ccd:RatioA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ] .

abstr:addObjectCapacity a :Abstraction ;
    cct:expression """    1: ObjectInfo(Nom);
    join_attr((get_attrL 1), (-: R2(Obj,Ratio)))""" ;
    :implementation multi:addObjectCapacity ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ;
            :id "1" ] ;
    :output [ a ccd:ERA,
                ccd:ObjectQ,
                ccd:PointA ] .

abstr:con1 a :Abstraction ;
    rdfs:comment "Cuts a field raster conditional on less than some value" ;
    cct:expression "select leq (1: Field(Ratio)) (-: Ratio)" ;
    :implementation arcgis:Con ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "raster" ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:con2 a :Abstraction ;
    rdfs:comment "Cuts a field raster conditional on (the coverage of) another field raster that is less than some value" ;
    cct:expression "subset (2: Field(Ratio)) (pi1 (select leq (1: Field(Ratio)) (-: Ratio)))" ;
    :implementation arcgis:Con ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "conditional raster, less than some value" ;
            :id "1" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "field raster to be cut" ;
            :id "2" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:con3 a :Abstraction ;
    rdfs:comment "Cuts a field raster conditional on (the coverage of) another field raster, and adds another field raster for those locations outside of the coverage" ;
    cct:expression """
        1: Field(Ratio);
        2: Field(Ratio);
        3: Field(Ratio);
        set_union
            (subset 2 (pi1 (select leq 1 (-: Ratio))))
            (subset 3 (pi1 (select eq (lTopo
                (pi1 3)
                (reify (pi1 (select leq 1 (-: Ratio))))
            ) out)))
        """ ;
    :implementation arcgis:Con ;
    :input [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "field raster to be cut for outside" ;
            :id "3" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "field raster to be cut for inside" ;
            :id "2" ],
        [ a ccd:FieldRaster,
                ccd:RatioA ;
            rdfs:comment "conditional raster, less than some value" ;
            :id "1" ] ;
    :output [ a ccd:FieldRaster,
                ccd:RatioA ] .

abstr:convert2PointObjects a :Abstraction ;
    cct:expression "subset (1: ObjectInfo(Nom)) (-: C(Nom))" ;
    :implementation multi:convert2PointObjects ;
    :input [ a ccd:ObjectQ,
                ccd:VectorTessellationA ;
            :id "1" ] ;
    :output [ a ccd:ObjectQ,
                ccd:PointA ] .

abstr:makePointObjects a :Abstraction ;
    cct:expression "generateobjects (1: ObjectInfo(Nom))" ;
    :implementation multi:makePointObjects ;
    :input [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PlainVectorRegionA ;
            :id "1" ] ;
    :output [ a ccd:NominalA,
                ccd:ObjectQ,
                ccd:PointA ] .

multi:ClosestFacilityAnalysis a :Multi ;
    :action [ :apply arcgis:AddLocations ;
            :input [ rdfs:comment "goals" ;
                    :id "2" ],
                _:N62ef45a8383540e49c42ff90dcd91a8b ;
            :output _:N6ac30ac3675f4710b21360e518ab76d5 ],
        [ :apply arcgis:MakeClosestFacilityAnalysisLayer ;
            :input [ rdfs:comment "roads" ;
                    :id "1" ] ;
            :output _:N62ef45a8383540e49c42ff90dcd91a8b ],
        [ :apply arcgis:Solve ;
            :input _:N5b4a5e517ae44b6f9c7c6c07c56a4416 ;
            :output [ ] ],
        [ :apply arcgis:AddLocations ;
            :input [ rdfs:comment "origins" ;
                    :id "3" ],
                _:N6ac30ac3675f4710b21360e518ab76d5 ;
            :output _:N5b4a5e517ae44b6f9c7c6c07c56a4416 ] .

arcgis:AddGeometryAttributes a :Unit ;
    rdfs:seeAlso arcdm:add-geometry-attributes.htm .

arcgis:AddJoin a :Unit ;
    rdfs:seeAlso arcdm:add-join.htm .

arcgis:AlterField a :Unit ;
    rdfs:seeAlso arcdm:alter-field-properties.htm .

arcgis:CollectEvents a :Unit ;
    rdfs:seeAlso arcss:collect-events.htm .

arcgis:Erase a :Unit ;
    rdfs:comment "Erase Vector fields" ;
    rdfs:seeAlso arcan:erase.htm .

arcgis:ExportTable a :Unit ;
    rdfs:seeAlso arcco:export-table.htm .

arcgis:ExtractByMask a :Unit ;
    rdfs:seeAlso arcsa:extract-by-mask.htm .

arcgis:FC2FC a :Unit ;
    rdfs:comment "Feature class to feature class (=Select)" ;
    rdfs:seeAlso arcco:feature-class-to-feature-class.htm .

arcgis:FeatureVerticesToPoints a :Unit ;
    rdfs:seeAlso arcdm:feature-vertices-to-points.htm .

arcgis:FlowAccumulation a :Unit ;
    rdfs:comment "Flow direction accumulation" ;
    rdfs:seeAlso arcsa:flow-accumulation.htm .

arcgis:FlowDirection a :Unit ;
    rdfs:comment "Flow direction raster" ;
    rdfs:seeAlso arcsa:flow-direction.htm .

arcgis:FlowLength a :Unit ;
    rdfs:seeAlso arcsa:flow-length.htm .

arcgis:GenerateNearTable a :Unit ;
    rdfs:seeAlso arcan:generate-near-table.htm .

arcgis:IDWInterval a :Unit ;
    rdfs:seeAlso arcsa:idw.htm .

arcgis:KernelDensity a :Unit ;
    rdfs:seeAlso arcsa:kernel-density.htm .

arcgis:KrigingInterval a :Unit ;
    rdfs:seeAlso arcsa:kriging.htm .

arcgis:MakeXyEventLayer a :Unit ;
    rdfs:seeAlso arcdm:make-xy-event-layer.htm .

arcgis:Merge a :Unit ;
    rdfs:seeAlso arcdm:merge.htm .

arcgis:NearPointObjects a :Unit ;
    rdfs:comment "Near tool, to seach for the closest objects using Euclidean distance" ;
    rdfs:seeAlso arcan:generate-near-table.htm .

arcgis:Project a :Unit ;
    rdfs:seeAlso arcdm:project.htm .

arcgis:SelectObjectByExtent a :Unit ;
    rdfs:seeAlso arcan:select.htm .

arcgis:Slope a :Unit ;
    rdfs:seeAlso arcsa:slope.htm .

arcgis:SnapPourPoint a :Unit ;
    rdfs:seeAlso arcsa:snap-pour-point.htm .

arcgis:TableToTable a :Unit ;
    rdfs:seeAlso arcco:table-to-table.htm .

arcgis:Watershed a :Unit ;
    rdfs:seeAlso arcsa:watershed.htm .

multi:BufferDissolve a :Multi ;
    :action [ :apply arcgis:Dissolve ;
            :input _:N4d663a175d3647c0acb5c70874f2239d ;
            :output [ ] ],
        [ :apply arcgis:Buffer ;
            :input [ :id "1" ] ;
            :output _:N4d663a175d3647c0acb5c70874f2239d ] .

multi:CalculateCountAmountRatio a :Multi ;
    :action [ :apply arcgis:AddFields ;
            :input [ :id "2" ] ;
            :output _:N6ed9bd2649a149d3ad69cdc40cef3add ],
        [ :apply arcgis:CalculateField ;
            :input _:N5a031938014b418d94a309cdba899fda ;
            :output _:N6f04345031214deb9f0c643aab772601 ],
        [ :apply arcgis:AddField ;
            :input [ :id "1" ] ;
            :output _:N5a031938014b418d94a309cdba899fda ],
        [ :apply arcgis:JoinField ;
            :input _:N65c0d736947c42019f8071cd83939fa9,
                _:N6f04345031214deb9f0c643aab772601 ;
            :output _:N2cc09164109a47319da01c62064c07d8 ],
        [ :apply arcgis:CalculateField ;
            :input _:N2cc09164109a47319da01c62064c07d8 ;
            :output [ ] ],
        [ :apply arcgis:CalculateField ;
            :input _:N6ed9bd2649a149d3ad69cdc40cef3add ;
            :output _:N65c0d736947c42019f8071cd83939fa9 ] .

multi:CalculateDensityonObject a :Multi ;
    :action [ :apply arcgis:AddField ;
            :input _:N07d6dd277a414d0f8b318bc04cd25dd5 ;
            :output _:N679708aae2794bcaa5dd5186ac08d89a ],
        [ :apply arcgis:CalculateField ;
            :input _:Nd9c280e51916444994fac1ad5e7d1eeb ;
            :output [ ] ],
        [ :apply arcgis:AddField ;
            :input [ :id "1" ] ;
            :output _:N07d6dd277a414d0f8b318bc04cd25dd5 ],
        [ :apply arcgis:CalculateGeometryAttributes ;
            :input _:N679708aae2794bcaa5dd5186ac08d89a ;
            :output _:Nd9c280e51916444994fac1ad5e7d1eeb ] .

multi:CalculateDiversity4onObjectVector a :Multi ;
    :action [ :apply arcgis:CalculateField ;
            :input [ :id "3" ],
                _:N2e5d2cccba574108b57e8a63c0fdd2cb,
                [ :id "1" ],
                [ :id "2" ] ;
            :output [ ] ],
        [ :apply arcgis:AddField ;
            :input [ :id "4" ] ;
            :output _:N2e5d2cccba574108b57e8a63c0fdd2cb ] .

multi:CalculateObjectVectorAmountRatio a :Multi ;
    :action [ :apply arcgis:AddField ;
            :input [ :id "2" ] ;
            :output _:N085f8a9516f047ffb5bb893860ac01ff ],
        [ :apply arcgis:CalculateField ;
            :input _:N085f8a9516f047ffb5bb893860ac01ff,
                [ :id "1" ] ;
            :output [ ] ] .

multi:CalculateObjectVectorDensity a :Multi ;
    :action [ :apply arcgis:CalculateField ;
            :input _:N8bc5a58ad7ae4a05a93e47a7a7286c6b ;
            :output [ ] ],
        [ :apply arcgis:AddGeometryAttributes ;
            :input [ :id "1" ] ;
            :output _:Nd8c005f88b724e8f9da1e04f5a448ec4 ],
        [ :apply arcgis:AddField ;
            :input _:Nd8c005f88b724e8f9da1e04f5a448ec4 ;
            :output _:N8bc5a58ad7ae4a05a93e47a7a7286c6b ] .

multi:CalculatePartialAmounts a :Multi ;
    rdfs:comment "Calculates a set of portions from a set of object based count amounts using some boolean vector field. Only the portions that are within the true value of the boolean field are considered. This is an areal interpolation problem, which is solved by first generating area proportions and then multiplying them with the count amount." ;
    :action [ :apply arcgis:CalculateField ;
            :input _:Nf7706f846ada4c6b887b195d9a908b52 ;
            :output _:N3063f3f3033b491e86679b0ef62442c7 ],
        [ :apply arcgis:Clip ;
            :input [ :id "1" ],
                [ :id "2" ] ;
            :output _:N6857320ae0d548358b3bd10c71658505 ],
        [ :apply arcgis:CalculateField ;
            :input _:N3063f3f3033b491e86679b0ef62442c7 ;
            :output [ ] ],
        [ :apply arcgis:AddFields ;
            :input _:N6857320ae0d548358b3bd10c71658505 ;
            :output _:Nf7706f846ada4c6b887b195d9a908b52 ] .

multi:CalculatePartialAmountsfromObjects a :Multi ;
    :action [ :apply arcgis:Clip ;
            :input [ :id "1" ],
                [ :id "2" ] ;
            :output _:N25035eec75db4b8096fc192ffc24d55c ],
        [ :apply arcgis:CalculateField ;
            :input _:N531532b66eee4ba097e3d364a61e8492 ;
            :output _:N7773212508104bf9b3e1ff4c1a1fc194 ],
        [ :apply arcgis:CalculateField ;
            :input _:N7773212508104bf9b3e1ff4c1a1fc194 ;
            :output [ ] ],
        [ :apply arcgis:AddFields ;
            :input _:N25035eec75db4b8096fc192ffc24d55c ;
            :output _:N531532b66eee4ba097e3d364a61e8492 ] .

multi:ClostestFacilityAnalysis a :Multi ;
    :action [ :apply arcgis:AddLocations ;
            :input _:N21f1d6d530444feea69f1c9096dbe921,
                [ :id "2" ] ;
            :output _:N13807649eb5c4cae8b3a2301bb59f4fa ],
        [ :apply arcgis:Solve ;
            :input _:Na552711751f64e74a7a013b57081beb0 ;
            :output [ ] ],
        [ :apply arcgis:AddLocations ;
            :input [ :id "3" ],
                _:N13807649eb5c4cae8b3a2301bb59f4fa ;
            :output _:Na552711751f64e74a7a013b57081beb0 ],
        [ :apply arcgis:MakeClosestFacilityAnalysisLayer ;
            :input [ :id "1" ] ;
            :output _:N21f1d6d530444feea69f1c9096dbe921 ] .

multi:ComputeCountDensityonObject a :Multi ;
    :action [ :apply arcgis:AddField ;
            :input _:Nf4b5eb3d17ac487080b633dea2c28717 ;
            :output _:N9500bf7caced4adca309e5362f566bb9 ],
        [ :apply arcgis:CalculateField ;
            :input _:Naaeb90e204944e5392ee92bd05d2dc7a ;
            :output [ ] ],
        [ :apply arcgis:CalculateField ;
            :input _:N9500bf7caced4adca309e5362f566bb9 ;
            :output _:N6c8f457a70c3476dba9d3965a1670696 ],
        [ :apply arcgis:AddField ;
            :input [ :id "1" ] ;
            :output _:Na970980dcede4614a7f432c384d8a36b ],
        [ :apply arcgis:CalculateGeometryAttributes ;
            :input _:Na970980dcede4614a7f432c384d8a36b ;
            :output _:Nf4b5eb3d17ac487080b633dea2c28717 ],
        [ :apply arcgis:AddField ;
            :input _:N6c8f457a70c3476dba9d3965a1670696 ;
            :output _:Naaeb90e204944e5392ee92bd05d2dc7a ] .

multi:ConvertDist2TravelTimeonObjects a :Multi ;
    :action [ :apply arcgis:CalculateField ;
            :input _:Na5193bcb29be41a8904c1c91fd87cdf8 ;
            :output [ ] ],
        [ :apply arcgis:AddField ;
            :input [ :id "1" ] ;
            :output _:Na5193bcb29be41a8904c1c91fd87cdf8 ] .

multi:CreateAndBuildNetwork a :Multi ;
    :action [ :apply arcgis:CreateNetworkDataset ;
            :input [ :id "1" ] ;
            :output _:N98fe308fcba54c769768e09b503a7e61 ],
        [ :apply arcgis:BuildNetwork ;
            :input _:N98fe308fcba54c769768e09b503a7e61 ;
            :output [ ] ] .

multi:CreateNetwork a :Multi ;
    :action [ :apply arcgis:CreateNetworkDataset ;
            :input [ :id "1" ] ;
            :output _:N90a05bdb55814b7ea8b201cafb74763e ],
        [ :apply arcgis:BuildNetwork ;
            :input _:N90a05bdb55814b7ea8b201cafb74763e ;
            :output [ ] ] .

multi:DerivePartsOfPopCenters a :Multi ;
    :action [ :apply arcgis:CalculateField ;
            :input _:N956eb7e8b6a643ceb47d34b205baea34 ;
            :output [ ] ],
        [ :apply arcgis:Clip ;
            :input [ :id "2" ],
                [ :id "1" ] ;
            :output _:N912f2c63fac245cc96a74e33a98cc8b8 ],
        [ :apply arcgis:AddField ;
            :input _:N4bcbfc59b55e4946ab1dd3ec3d7122ab ;
            :output _:N956eb7e8b6a643ceb47d34b205baea34 ],
        [ :apply arcgis:CalculateGeometryAttributes ;
            :input _:N912f2c63fac245cc96a74e33a98cc8b8 ;
            :output _:N4bcbfc59b55e4946ab1dd3ec3d7122ab ] .

multi:GenerateIntersections a :Multi ;
    :action [ :apply arcgis:FeatureVerticesToPoints ;
            :input [ :id "1" ] ;
            :output _:N252fbfd90c4743bf8cd220a8e4929c17 ],
        [ :apply arcgis:CollectEvents ;
            :input _:N252fbfd90c4743bf8cd220a8e4929c17 ;
            :output _:Nfeefe970808e4824b84ab1672eb85103 ],
        [ :apply arcgis:SelectLayerByAttribute ;
            :input _:Nfeefe970808e4824b84ab1672eb85103 ;
            :output [ ] ] .

multi:InterpolateDensityonObjects2LineObject a :Multi ;
    :action [ :apply arcgis:Intersect ;
            :input [ :id "2" ],
                [ :id "1" ] ;
            :output _:N5027db52e9184d0286b0cd7799309df7 ],
        [ :apply arcgis:SummaryStatistics ;
            :input _:N5027db52e9184d0286b0cd7799309df7 ;
            :output [ ] ] .

multi:IntersectDissolve a :Multi ;
    rdfs:comment "this tool computes the coverage of a field inside object region by first intersecting and then dissolving  and joining, to obtain the area covered by the field inside the object region" ;
    :action [ :apply arcgis:MergeObjects ;
            :input _:Nbabf447c3d064ca387f85a91984aac45 ;
            :output _:N07a409a027fe4832a9081a01ddddfe64 ],
        [ :apply arcgis:Intersect ;
            :input [ :id "1" ],
                _:Nf5534e7c33d84a3bb0016608a09f2f87 ;
            :output _:Nbabf447c3d064ca387f85a91984aac45 ],
        [ :apply arcgis:JoinField ;
            :input _:N07a409a027fe4832a9081a01ddddfe64,
                _:Nf5534e7c33d84a3bb0016608a09f2f87 ;
            :output [ ] ] .

multi:JoinCountAttribute a :Multi ;
    :action [ :apply arcgis:JoinField ;
            :input [ :id "1" ],
                [ :id "2" ] ;
            :output _:N567bfb6459324d568c16a231fed16f4f ],
        [ :apply arcgis:CopyFeatures ;
            :input _:N567bfb6459324d568c16a231fed16f4f ;
            :output [ ] ] .

multi:JoinFromTable a :Multi ;
    rdfs:comment "Make table from Excel" ;
    :action [ :apply arcgis:JoinField ;
            :input _:N0b84be35dcd0436a89219952cdc2d617,
                [ :id "2" ] ;
            :output [ ] ],
        [ :apply arcgis:ExcelToTable ;
            :input [ :id "1" ] ;
            :output _:N0b84be35dcd0436a89219952cdc2d617 ] .

multi:JoinObjectRatios a :Multi ;
    :action [ :apply arcgis:ExportFeatures ;
            :input _:Nfa4a8cee82f145fd930b1b70a74fafe7 ;
            :output [ ] ],
        [ :apply arcgis:AddJoin ;
            :input [ :id "2" ],
                [ :id "1" ] ;
            :output _:Nfa4a8cee82f145fd930b1b70a74fafe7 ] .

multi:LoadCountAmounts a :Multi ;
    :action [ :apply arcgis:CalculateField ;
            :input _:Nd2eda5881a0f4edeaca8f236d3c2e5a2 ;
            :output [ ] ],
        [ :apply arcgis:CopyFeatures ;
            :input [ :id "2" ] ;
            :output _:N1a2291155cf84fdfbc2618dda91c2c95 ],
        [ :apply arcgis:JoinField ;
            :input _:N1a2291155cf84fdfbc2618dda91c2c95,
                [ :id "1" ] ;
            :output _:N1c585005446c425f915272b00bf79f89 ],
        [ :apply arcgis:AddField ;
            :input _:N1c585005446c425f915272b00bf79f89 ;
            :output _:Nd2eda5881a0f4edeaca8f236d3c2e5a2 ] .

multi:MakeLayerFromTable a :Multi ;
    :action [ :apply arcgis:ExcelToTable ;
            :input _:N9c7d0893c72946a8a08a159f76c022bc ;
            :output _:N6f1c67c78dff46f3915d6a74f0d95bba ],
        [ :apply arcgis:MakeXyEventLayer ;
            :input _:N9c7d0893c72946a8a08a159f76c022bc ;
            :output _:N6ea64780f75f499d8221d746e8dee82b ],
        [ :apply arcgis:Project ;
            :input _:N6ea64780f75f499d8221d746e8dee82b ;
            :output _:Na3f340ba630d40749e13481cdb37112b ],
        [ :apply arcgis:JoinField ;
            :input _:N6f1c67c78dff46f3915d6a74f0d95bba,
                _:Na3f340ba630d40749e13481cdb37112b ;
            :output [ ] ] .

multi:RasterCoverage a :Multi ;
    rdfs:comment "Computes coverage (size) from a raster table for each raster value" ;
    :action [ :apply arcgis:AddField ;
            :input _:N4f4f5080745841c7b6437cfa39a178e4 ;
            :output _:N290f071c648a4577b47e9f476cb4f9ac ],
        [ :apply arcgis:CalculateField ;
            :input _:N290f071c648a4577b47e9f476cb4f9ac ;
            :output [ ] ],
        [ :apply arcgis:TableToTable ;
            :input [ :id "1" ] ;
            :output _:N4f4f5080745841c7b6437cfa39a178e4 ] .

multi:RasterToContour a :Multi ;
    :action [ :apply arcgis:RegionFromRasterExtent ;
            :input _:Ne8efcdfab2134532b1c49a9f9da470ea ;
            :output [ ] ],
        [ :apply arcgis:RasterToIsoRaster ;
            :input [ :id "1" ] ;
            :output _:Ne8efcdfab2134532b1c49a9f9da470ea ] .

multi:RouteAnalysis a :Multi ;
    :action [ :apply arcgis:Solve ;
            :input _:N20cdbd2bf82245e2927c7d633d898706 ;
            :output [ ] ],
        [ :apply arcgis:MakeRouteAnalysisLayer ;
            :input [ :id "1" ] ;
            :output _:Ne7a2361eec564c559d4d0b5b67c507a9 ],
        [ :apply arcgis:AddLocations ;
            :input [ :id "2" ],
                _:Ne7a2361eec564c559d4d0b5b67c507a9 ;
            :output _:N7502f796f587461cb7261cdf10cab9ad ],
        [ :apply arcgis:AddLocations ;
            :input [ :id "3" ],
                _:N7502f796f587461cb7261cdf10cab9ad ;
            :output _:N20cdbd2bf82245e2927c7d633d898706 ] .

multi:SelectLayerByAttributeTessObjects a :Multi ;
    :action [ :apply arcgis:FeatureClassToFeatureClass ;
            :input _:Nfdc4417ca2ac4a14bf88faa473a180be ;
            :output [ ] ],
        [ :apply arcgis:SelectLayerByAttribute ;
            :input [ :id "1" ] ;
            :output _:Nfdc4417ca2ac4a14bf88faa473a180be ] .

multi:SelectLayerByLocationDistTessObject a :Multi ;
    :action [ :apply arcgis:ExportFeatures ;
            :input _:Nc716a0d1f9a043da826c1062db1e3ca6 ;
            :output [ ] ],
        [ :apply arcgis:SelectLayerByLocation ;
            :input [ :id "2" ],
                [ :id "1" ] ;
            :output _:Nc716a0d1f9a043da826c1062db1e3ca6 ] .

multi:SelectLayerByLocationPointObjects1 a :Multi ;
    :action [ :apply arcgis:CopyFeatures ;
            :input _:Nb1e4329dabb245a78ebaacdedb7b781e ;
            :output [ ] ],
        [ :apply arcgis:SelectLayerByLocation ;
            :input [ :id "2" ],
                [ :id "1" ] ;
            :output _:Nb1e4329dabb245a78ebaacdedb7b781e ] .

multi:SelectLayerByLocationPointObjects2 a :Multi ;
    :action [ :apply arcgis:CopyFeatures ;
            :input _:N70bed7b0512048f389781e75335aa09d ;
            :output [ ] ],
        [ :apply arcgis:SelectLayerByLocation ;
            :input [ :id "1" ],
                [ :id "2" ] ;
            :output _:N70bed7b0512048f389781e75335aa09d ] .

multi:SelectLayerByLocationTessObject a :Multi ;
    :action [ :apply arcgis:ExportFeatures ;
            :input _:Nabb19552fb1f4343a861d3f853c6cd1d ;
            :output [ ] ],
        [ :apply arcgis:SelectLayerByLocation ;
            :input [ :id "2" ],
                [ :id "1" ] ;
            :output _:Nabb19552fb1f4343a861d3f853c6cd1d ] .

multi:SelectNeighborhoodsByAttributeTessObjects a :Multi ;
    :action [ :apply arcgis:ExportFeatures ;
            :input _:N23ecae5906a64339baedf1907b624b6a ;
            :output [ ] ],
        [ :apply arcgis:SelectLayerByAttribute ;
            :input [ :id "1" ] ;
            :output _:N23ecae5906a64339baedf1907b624b6a ] .

multi:SelectNeighborhoodsByLocationDistPointObject a :Multi ;
    :action [ :apply arcgis:ExportFeatures ;
            :input _:Nbc7f21f7ce244d5f95c3f3bad93fc7f0 ;
            :output [ ] ],
        [ :apply arcgis:SelectLayerByLocation ;
            :input [ :id "1" ],
                [ :id "2" ] ;
            :output _:Nbc7f21f7ce244d5f95c3f3bad93fc7f0 ] .

multi:SelectNeighborhoodsByRatioObjects a :Multi ;
    :action [ :apply arcgis:SelectLayerByAttribute ;
            :input [ :id "1" ] ;
            :output _:Nfcb05b248fd24e2aacc754e06bdbfe5b ],
        [ :apply arcgis:ExportFeatures ;
            :input _:Nfcb05b248fd24e2aacc754e06bdbfe5b ;
            :output [ ] ] .

multi:SelectSchoolsByLocationPointObject a :Multi ;
    :action [ :apply arcgis:SelectLayerByLocation ;
            :input [ :id "1" ],
                [ :id "2" ] ;
            :output _:N018057f8b4714d79bf019f2043aa78d4 ],
        [ :apply arcgis:ExportFeatures ;
            :input _:N018057f8b4714d79bf019f2043aa78d4 ;
            :output [ ] ] .

multi:SelectWOZByRatioObjects a :Multi ;
    :action [ :apply arcgis:SelectLayerByAttribute ;
            :input [ :id "1" ] ;
            :output _:N8068d9012c4a4eaa9bd14ddbeecc69df ],
        [ :apply arcgis:ExportTable ;
            :input _:N8068d9012c4a4eaa9bd14ddbeecc69df ;
            :output [ ] ] .

multi:TSPRouting a :Multi ;
    :action [ :apply arcgis:AddLocations ;
            :input [ :id "2" ],
                _:Nc56e6dc5ff3c49a5ad232a0956596430 ;
            :output _:N992e0ae4ad994ed6b6c9744176734090 ],
        [ :apply arcgis:Solve ;
            :input _:N8350d1e95c434e78a94d90776270362b ;
            :output [ ] ],
        [ :apply arcgis:AddLocations ;
            :input [ :id "3" ],
                _:N992e0ae4ad994ed6b6c9744176734090 ;
            :output _:N8350d1e95c434e78a94d90776270362b ],
        [ :apply arcgis:MakeRouteAnalysisLayer ;
            :input [ :id "1" ] ;
            :output _:Nc56e6dc5ff3c49a5ad232a0956596430 ] .

multi:VelocityField a :Multi ;
    rdfs:comment """Computes a water flow velocity raster from slope * accumulation area

    # Select by attribute is always followed by copying features
    # This computes SquareRoot("slope") * SquareRoot("flow_accumulation")
    """ ;
    :action [ :apply arcgis:RasterCalculator ;
            :input [ :id "1" ],
                [ :id "2" ] ;
            :output _:N46bf20d04b2a4ea5801076b07e46d634 ],
        [ rdfs:comment "This second step computes 0.1 * (Stowe_slope_area_term / [Mean slope-area term]). It needs looking up of parameter [Mean slope-area term]." ;
            :apply arcgis:RasterCalculator1 ;
            :input _:N46bf20d04b2a4ea5801076b07e46d634 ;
            :output [ ] ] .

multi:ZonalStatisticsSumField a :Multi ;
    :action [ :apply arcgis:JoinField ;
            :input _:N60e0ea0023904bb7baa3177ddca5a809,
                _:Nb341dcb9024d4b37bb81aff5517c4a40 ;
            :output [ ] ],
        [ :apply arcgis:ZonalStatisticsAsTable ;
            :input _:N60e0ea0023904bb7baa3177ddca5a809,
                [ :id "1" ] ;
            :output _:Ndddcab312f8649f7a1c5f4126b34d957 ],
        [ :apply arcgis:AlterField ;
            :input _:Ndddcab312f8649f7a1c5f4126b34d957 ;
            :output _:Nb341dcb9024d4b37bb81aff5517c4a40 ] .

multi:addObjectCapacity a :Multi ;
    :action [ :apply arcgis:AddField ;
            :input [ :id "1" ] ;
            :output _:N03d73df379d24fde9acd3fd5186d793b ],
        [ :apply arcgis:CalculateField ;
            :input _:N03d73df379d24fde9acd3fd5186d793b ;
            :output [ ] ] .

multi:convert2PointObjects a :Multi ;
    :action [ :apply arcgis:SelectLayerByAttribute ;
            :input [ :id "1" ] ;
            :output _:Nc9dd80f4327b4ca993ab606a1f0729b5 ],
        [ :apply arcgis:FeatureToPoint ;
            :input _:Nc9dd80f4327b4ca993ab606a1f0729b5 ;
            :output [ ] ] .

multi:makePointObjects a :Multi ;
    :action [ :apply arcgis:FeatureToPoint ;
            :input [ :id "1" ] ;
            :output _:N6e8ba42d545643a8abe2202591e12f50 ],
        [ :apply arcgis:CreateRandomPoints ;
            :input _:N6e8ba42d545643a8abe2202591e12f50 ;
            :output [ ] ] .

arcgis:Buffer a :Unit ;
    rdfs:seeAlso arcan:buffer.htm .

arcgis:BuildNetwork a :Unit ;
    rdfs:comment "Builds ratio network from line objects" ;
    rdfs:seeAlso arcna:build-network.htm .

arcgis:CreateNetworkDataset a :Unit ;
    rdfs:seeAlso arcna:create-network-dataset.htm .

arcgis:CreateRandomPoints a :Unit ;
    rdfs:seeAlso arcdm:create-random-points.htm .

arcgis:Dissolve a :Unit ;
    rdfs:comment "Merge object parts into single object" ;
    rdfs:seeAlso arcdm:dissolve.htm .

arcgis:ExcelToTable a :Unit ;
    rdfs:seeAlso arcco:excel-to-table.htm .

arcgis:FeatureToPoint a :Unit ;
    rdfs:seeAlso arcdm:feature-to-point.htm .

arcgis:Intersect a :Unit ;
    rdfs:seeAlso arcan:intersect.htm .

arcgis:MakeClosestFacilityAnalysisLayer a :Unit ;
    rdfs:seeAlso arcna:make-closest-facility-analysis-layer.htm .

arcgis:MakeRouteAnalysisLayer a :Unit ;
    rdfs:seeAlso arcna:make-route-analysis-layer.htm .

arcgis:PolygonToRaster a :Unit ;
    rdfs:seeAlso arcco:polygon-to-raster.htm .

arcgis:RasterToIsoRaster a :Unit ;
    rdfs:seeAlso arcsa:reclassify.htm .

arcgis:RegionFromRasterExtent a :Unit ;
    rdfs:seeAlso arcco:raster-to-polygon.htm .

arcgis:SummarizeWithin a :Unit ;
    rdfs:seeAlso arcan:summarize-within.htm .

arcgis:ZonalStatisticsAsTable a :Unit ;
    rdfs:seeAlso arcsa:zonal-statistics-as-table.htm .

multi:FullSelectFeatures a :Multi ;
    rdfs:comment "Query to select items from layers using attribut values" ;
    :action [ :apply arcgis:FC2FCObjectTess ;
            :input _:N35c0ece559b243ec9747cc63936141f3 ;
            :output [ ] ],
        [ rdfs:comment "Select by attribute is always followed by copying features" ;
            :apply arcgis:SelectLayerByAttribute ;
            :input [ :id "1" ] ;
            :output _:N35c0ece559b243ec9747cc63936141f3 ] .

arcgis:AddFields a :Unit ;
    rdfs:seeAlso arcdm:add-fields.htm .

arcgis:CalculateGeometryAttributes a :Unit ;
    rdfs:seeAlso arcdm:calculate-geometry-attributes.htm .

arcgis:Con a :Unit ;
    rdfs:seeAlso arcsa:con-.htm .

arcgis:FeatureClassToFeatureClass a :Unit ;
    rdfs:seeAlso arcco:feature-class-to-feature-class.htm .

multi:AddandCalculateAttribute a :Multi ;
    rdfs:comment "Add an attribute and calculate value based on one other attribute" ;
    :action [ :apply arcgis:AddField ;
            :input [ :id "1" ] ;
            :output _:N6717c2ed4e12426dab30da8700305b3c ],
        [ :apply arcgis:CalculateField ;
            :input _:N6717c2ed4e12426dab30da8700305b3c ;
            :output [ ] ] .

arcgis:Solve a :Unit ;
    rdfs:seeAlso arcna:solve.htm .

multi:ZonalStatistics a :Multi ;
    :action [ :apply arcgis:JoinField ;
            :input _:Nabd70f556ceb482fbeef2bd5cb25e3f4,
                _:Ne90704518e5d4126a673462a94b8fc07 ;
            :output [ ] ],
        [ :apply arcgis:ZonalStatisticsAsTable ;
            :input [ :id "1" ],
                _:Nabd70f556ceb482fbeef2bd5cb25e3f4 ;
            :output _:Ne90704518e5d4126a673462a94b8fc07 ] .

arcgis:RasterCalculator a :Unit ;
    rdfs:seeAlso arcsa:raster-calculator.htm .

multi:CalculateAreaMeasure a :Multi ;
    rdfs:comment "This is an abbreviated workflow for calculating area based measures with attributes" ;
    :action [ :apply arcgis:CalculateField2 ;
            :input [ :id "2" ],
                _:Ne0d8ba9c32f44be2a3bba22e1bbd3aa5 ;
            :output [ ] ],
        [ :apply arcgis:AddField ;
            :input [ :id "1" ] ;
            :output _:Ne0d8ba9c32f44be2a3bba22e1bbd3aa5 ] .

arcgis:CopyFeatures a :Unit ;
    rdfs:seeAlso arcdm:copy-features .

arcgis:SummaryStatistics a :Unit ;
    rdfs:seeAlso arcan:summary-statistics.htm .

multi:FullSelectLayerByLocation a :Multi ;
    :action [ :apply arcgis:SelectLayerByLocation ;
            :input [ :id "2" ],
                [ :id "1" ] ;
            :output _:Nb153927a5e99428ab2d709fbaf412357 ],
        [ :apply arcgis:CopyFeatures ;
            :input _:Nb153927a5e99428ab2d709fbaf412357 ;
            :output [ ] ] .

arcgis:Clip a :Unit ;
    rdfs:seeAlso arcan:clip.htm,
        arcdm:clip.htm .

arcgis:AddLocations a :Unit ;
    rdfs:seeAlso arcna:add-locations.htm .

arcgis:ExportFeatures a :Unit ;
    rdfs:seeAlso arcco:export-features.htm .

arcgis:JoinField a :Unit ;
    rdfs:seeAlso arcdm:join-field.htm .

arcgis:SelectLayerByLocation a :Unit ;
    rdfs:seeAlso arcdm:select-layer-by-location.htm .

arcgis:SpatialJoin a :Unit ;
    rdfs:seeAlso arcan:spatial-join.htm .

arcgis:SelectLayerByAttribute a :Unit ;
    rdfs:seeAlso arcdm:select-layer-by-attribute.htm .

multi:FullSelectLayerByAttribute a :Multi ;
    rdfs:comment "Select by attribute is always followed by copy features (treated as one tool in the annotation",
        "a SQL query to select features matching a selection criterion. You build a query expression to generate the subset. You can query a dataset based on a field in a layer or a table. Using this selection a new Feature dataset is created with only the selected features using the 'Copy Features tool'. This feature dataset represents all the areas that fulfill the criterion" ;
    :action [ :apply arcgis:CopyFeatures ;
            :input _:Nb00b0d7425864299a68a67f5e31511fb ;
            :output [ ] ],
        [ :apply arcgis:SelectLayerByAttribute ;
            :input [ :id "1" ] ;
            :output _:Nb00b0d7425864299a68a67f5e31511fb ] .

arcgis:AddField a :Unit ;
    rdfs:seeAlso arcdm:add-field.htm .

arcgis:CalculateField a :Unit ;
    rdfs:seeAlso arcdm:calculate-field.htm .

_:N60e0ea0023904bb7baa3177ddca5a809 :id "2" .

_:N9c7d0893c72946a8a08a159f76c022bc :id "1" .

_:Nabd70f556ceb482fbeef2bd5cb25e3f4 :id "2" .

_:Nf5534e7c33d84a3bb0016608a09f2f87 :id "2" .

